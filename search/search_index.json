{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Magetools: Dynamic Tool Discovery for AI Agents","text":"<p>Magetools is a high-performance framework for Active Tool Discovery. It allows AI agents to dynamically find, load, and execute Python functions as tools at runtime, using a decentralized \"Grimorium\" (portable spellbook) pattern.</p>"},{"location":"#why-magetools","title":"\ud83e\uddd9\u200d\u2642\ufe0f Why Magetools?","text":"<ul> <li>Active Discovery: Tools are discovered from the filesystem at runtime, not hardcoded into the agent.</li> <li>Strict Security: Optional \"Strict Mode\" requires cryptographic manifests for every tool collection.</li> <li>Provider Agnostic: Works with any LLM, with built-in optimizations for Google GenAI.</li> <li>Zero Config: Drop tools into a folder, and the agent finds them.</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code>from magetools.grimorium import Grimorium\n\n# 1. Initialize the spellbook\ngrim = Grimorium()\n\n# 2. Discover tools in .magetools/\nawait grim.initialize()\n\n# 3. Use tools in your agent\n# (Magetools handles the indexing and semantic search)\n</code></pre>"},{"location":"#contents","title":"\ud83d\udcda Contents","text":"<ul> <li>Getting Started</li> <li>Core Concepts</li> <li>Security &amp; Strict Mode</li> <li>CLI Reference</li> </ul>"},{"location":"reference/adapters/","title":"Adapters","text":"<p>Adapters for Magetools.</p> <p>This module provides concrete implementations of the embedding and vector store protocols. Dependencies (chromadb, google-genai) are lazily imported to allow the core magetools package to be used with alternative providers.</p>"},{"location":"reference/adapters/#magetools.adapters.ChromaVectorStore","title":"<code>ChromaVectorStore</code>","text":"<p>               Bases: <code>VectorStoreProtocol</code></p> <p>Adapter for ChromaDB.</p> Source code in <code>src/magetools/adapters.py</code> <pre><code>class ChromaVectorStore(VectorStoreProtocol):\n    \"\"\"Adapter for ChromaDB.\"\"\"\n\n    def __init__(self, path: str):\n        chromadb, _ = _import_chromadb()\n        self.client = chromadb.PersistentClient(path=str(path))\n\n    def get_collection(self, name: str, embedding_function: Any) -&gt; Any:\n        return self.client.get_collection(\n            name=name, embedding_function=embedding_function\n        )\n\n    def list_collections(self) -&gt; list[Any]:\n        return self.client.list_collections()\n\n    def get_or_create_collection(self, name: str, embedding_function: Any) -&gt; Any:\n        return self.client.get_or_create_collection(\n            name=name, embedding_function=embedding_function\n        )\n\n    async def close(self) -&gt; None:\n        \"\"\"Close database connection.\"\"\"\n        self.client = None\n</code></pre>"},{"location":"reference/adapters/#magetools.adapters.GoogleGenAIProvider","title":"<code>GoogleGenAIProvider</code>","text":"<p>               Bases: <code>EmbeddingProviderProtocol</code></p> <p>Provider for Google Generative AI embeddings.</p> Source code in <code>src/magetools/adapters.py</code> <pre><code>class GoogleGenAIProvider(EmbeddingProviderProtocol):\n    \"\"\"Provider for Google Generative AI embeddings.\"\"\"\n\n    def __init__(self, config: MageToolsConfig | None = None):\n        self.config = config or get_config()\n        genai = _import_genai()\n        self.client = genai.Client()\n        self._genai = genai\n\n    def get_embedding_function(self) -&gt; Any:\n        _, embedding_functions = _import_chromadb()\n        return embedding_functions.GoogleGenerativeAiEmbeddingFunction(\n            model_name=self.config.embedding_model, task_type=\"SEMANTIC_SIMILARITY\"\n        )\n\n    def generate_content(self, prompt: str) -&gt; str:\n        \"\"\"Generates content using Google Gemini model.\"\"\"\n        logger.debug(f\"Generating content with model {self.config.model_name}...\")\n        response = self.client.models.generate_content(\n            model=self.config.model_name, contents=prompt\n        )\n        logger.debug(\"Generated content.\")\n        return response.text\n\n    async def close(self) -&gt; None:\n        \"\"\"Cleanup AI client.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/adapters/#magetools.adapters.MockEmbeddingProvider","title":"<code>MockEmbeddingProvider</code>","text":"<p>               Bases: <code>EmbeddingProviderProtocol</code></p> <p>Mock provider for when google-genai is not available.</p> <p>This allows users to try the library without credentials. Search functionality will be degraded but the app won't crash.</p> Source code in <code>src/magetools/adapters.py</code> <pre><code>class MockEmbeddingProvider(EmbeddingProviderProtocol):\n    \"\"\"Mock provider for when google-genai is not available.\n\n    This allows users to try the library without credentials.\n    Search functionality will be degraded but the app won't crash.\n    \"\"\"\n\n    def __init__(self, config: MageToolsConfig | None = None):\n        self.config = config or get_config()\n        logger.warning(\n            \"Using MockEmbeddingProvider - search functionality will be limited. \"\n            \"Install google-genai and set GOOGLE_API_KEY for full functionality.\"\n        )\n\n    def get_embedding_function(self) -&gt; Any:\n        \"\"\"Return a simple mock embedding function.\"\"\"\n        return _MockEmbeddingFunction()\n\n    def generate_content(self, prompt: str) -&gt; str:\n        \"\"\"Return a placeholder summary.\"\"\"\n        logger.debug(\"MockProvider: Returning placeholder summary\")\n        return \"Summary not available (MockProvider - no LLM configured)\"\n\n    async def close(self) -&gt; None:\n        \"\"\"No-op cleanup.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/config/","title":"Configuration","text":"<p>Configuration loader for magetools.</p> Source code in <code>src/magetools/config.py</code> <pre><code>class MageToolsConfig:\n    \"\"\"Configuration loader for magetools.\"\"\"\n\n    def __init__(\n        self,\n        root_path: Path | None = None,\n        config_path: Path | None = None,\n    ):\n        self.root_path = root_path or Path.cwd()\n\n        # Load defaults\n        self.magetools_dir_name = os.getenv(\"MAGETOOLS_DIR_NAME\", DEFAULT_MAGETOOLS_DIR)\n        self.db_folder_name = os.getenv(\"MAGETOOLS_DB_FOLDER\", DEFAULT_DB_FOLDER)\n        self.model_name = os.getenv(\"MAGETOOLS_MODEL\", DEFAULT_MODEL)\n        self.embedding_model = os.getenv(\n            \"MAGETOOLS_EMBEDDING_MODEL\", DEFAULT_EMBEDDING_MODEL\n        )\n        self.debug = os.getenv(\"MAGETOOLS_DEBUG\", \"false\").lower() == \"true\"\n\n        # Load from YAML if exists\n        self.config_path = config_path or self.root_path / \"magetools.yaml\"\n        if self.config_path.exists():\n            self._load_from_yaml(self.config_path)\n\n    def _load_from_yaml(self, path: Path):\n        try:\n            with open(path, encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n                if data:\n                    self.magetools_dir_name = data.get(\n                        \"magetools_dir_name\", self.magetools_dir_name\n                    )\n                    self.db_folder_name = data.get(\n                        \"db_folder_name\", self.db_folder_name\n                    )\n                    self.model_name = data.get(\"model_name\", self.model_name)\n                    self.embedding_model = data.get(\n                        \"embedding_model\", self.embedding_model\n                    )\n                    self.debug = data.get(\"debug\", self.debug)\n        except Exception as e:\n            logger.error(f\"Failed to load config from {path}: {e}\")\n\n    @property\n    def magetools_root(self) -&gt; Path:\n        \"\"\"Absolute path to the .magetools directory.\"\"\"\n        return (self.root_path / self.magetools_dir_name).resolve()\n\n    @property\n    def db_path(self) -&gt; Path:\n        \"\"\"Absolute path to the database folder.\"\"\"\n        return (self.magetools_root / self.db_folder_name).resolve()\n\n    def validate(self, require_magetools_dir: bool = False) -&gt; list[str]:\n        \"\"\"Validate configuration and return list of warnings.\n\n        Args:\n            require_magetools_dir: If True, raises ConfigurationError if .magetools doesn't exist.\n\n        Returns:\n            List of warning messages (non-fatal issues).\n        \"\"\"\n        from .exceptions import ConfigurationError\n\n        warnings = []\n\n        # Check if root_path exists\n        if not self.root_path.exists():\n            raise ConfigurationError(\n                f\"Root path does not exist: {self.root_path}. \"\n                \"Provide a valid root_path or check your working directory.\"\n            )\n\n        # Check if magetools directory exists\n        if not self.magetools_root.exists():\n            if require_magetools_dir:\n                raise ConfigurationError(\n                    f\"Magetools directory not found at {self.magetools_root}. \"\n                    f\"Create a '{self.magetools_dir_name}' folder to store your spells.\"\n                )\n            else:\n                warnings.append(\n                    f\"Magetools directory not found at {self.magetools_root}. \"\n                    \"Spell discovery will not find any spells.\"\n                )\n\n        return warnings\n</code></pre>"},{"location":"reference/config/#magetools.config.MageToolsConfig.db_path","title":"<code>db_path</code>  <code>property</code>","text":"<p>Absolute path to the database folder.</p>"},{"location":"reference/config/#magetools.config.MageToolsConfig.magetools_root","title":"<code>magetools_root</code>  <code>property</code>","text":"<p>Absolute path to the .magetools directory.</p>"},{"location":"reference/config/#magetools.config.MageToolsConfig.validate","title":"<code>validate(require_magetools_dir=False)</code>","text":"<p>Validate configuration and return list of warnings.</p> <p>Parameters:</p> Name Type Description Default <code>require_magetools_dir</code> <code>bool</code> <p>If True, raises ConfigurationError if .magetools doesn't exist.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of warning messages (non-fatal issues).</p> Source code in <code>src/magetools/config.py</code> <pre><code>def validate(self, require_magetools_dir: bool = False) -&gt; list[str]:\n    \"\"\"Validate configuration and return list of warnings.\n\n    Args:\n        require_magetools_dir: If True, raises ConfigurationError if .magetools doesn't exist.\n\n    Returns:\n        List of warning messages (non-fatal issues).\n    \"\"\"\n    from .exceptions import ConfigurationError\n\n    warnings = []\n\n    # Check if root_path exists\n    if not self.root_path.exists():\n        raise ConfigurationError(\n            f\"Root path does not exist: {self.root_path}. \"\n            \"Provide a valid root_path or check your working directory.\"\n        )\n\n    # Check if magetools directory exists\n    if not self.magetools_root.exists():\n        if require_magetools_dir:\n            raise ConfigurationError(\n                f\"Magetools directory not found at {self.magetools_root}. \"\n                f\"Create a '{self.magetools_dir_name}' folder to store your spells.\"\n            )\n        else:\n            warnings.append(\n                f\"Magetools directory not found at {self.magetools_root}. \"\n                \"Spell discovery will not find any spells.\"\n            )\n\n    return warnings\n</code></pre>"},{"location":"reference/grimorium/","title":"Grimorium","text":"<p>               Bases: <code>BaseToolset</code></p> <p>A magical grimoire toolset for discovering and managing spells.</p> <p>This toolset provides three main tools: 1. magetools_discover_grimoriums: To find relevant collections (Grimoriums). 2. magetools_discover_spells: To find spells within a Grimorium. 3. magetools_execute_spell: To run a specific spell.</p> Usage <p>grimorium = Grimorium(root_path=\"/path/to/project\") await grimorium.initialize()  # Required before use</p> Source code in <code>src/magetools/grimorium.py</code> <pre><code>class Grimorium(BaseToolset):\n    \"\"\"A magical grimoire toolset for discovering and managing spells.\n\n    This toolset provides three main tools:\n    1. magetools_discover_grimoriums: To find relevant collections (Grimoriums).\n    2. magetools_discover_spells: To find spells within a Grimorium.\n    3. magetools_execute_spell: To run a specific spell.\n\n    Usage:\n        grimorium = Grimorium(root_path=\"/path/to/project\")\n        await grimorium.initialize()  # Required before use\n    \"\"\"\n\n    def __init__(\n        self,\n        root_path: str | None = None,\n        allowed_collections: list[str] | None = None,\n        embedding_provider: Any = None,\n        vector_store: Any = None,\n        config: MageToolsConfig | None = None,\n        strict_mode: bool = True,\n        auto_initialize: bool = True,\n    ):\n        \"\"\"Initialize the Grimorium toolset.\n\n        Args:\n            root_path: Optional path string to the project root.\n            allowed_collections: Optional list of collection names.\n            embedding_provider: Optional EmbeddingProviderProtocol implementation.\n            vector_store: Optional VectorStoreProtocol implementation.\n            config: Optional MageToolsConfig object.\n            strict_mode: If True, only load spells from folders with manifest.json.\n            auto_initialize: If True (default), run sync initialization in constructor\n                           for backwards compatibility. Set to False for async usage.\n        \"\"\"\n        # Initialize the base toolset with a prefix to avoid naming collisions\n        super().__init__(tool_name_prefix=\"magetools\")\n\n        self.config = config or get_config(\n            root_path=Path(root_path) if root_path else None\n        )\n        path_obj = self.config.root_path\n\n        # If root_path specifically provided, we trust it over auto-detection\n        # but if neither provided, we use the auto-detection from previous version as fallback for compatibility\n        if not root_path and not config:\n            # Magic: Auto-detect the caller's frame to find where Grimorium is instantiated\n            try:\n                # Stack[0] is here, Stack[1] is the caller\n                frame = inspect.stack()[1]\n                caller_file = frame.filename\n                if caller_file:\n                    path_obj = Path(caller_file).parent.resolve()\n                    logger.debug(\n                        f\"Auto-detected Grimorium root from caller: {path_obj}\"\n                    )\n            except Exception as e:\n                logger.warning(f\"Could not auto-detect caller path: {e}\")\n\n            # Fallback to CWD if magic failed and no path provided\n            if not path_obj:\n                path_obj = Path.cwd()\n\n            # Update config with the auto-detected path\n            self.config.root_path = path_obj\n\n        self.spell_sync = SpellSync(\n            root_path=self.config.root_path,\n            allowed_collections=allowed_collections,\n            embedding_provider=embedding_provider,\n            vector_store=vector_store,\n            config=self.config,\n        )\n\n        self._strict_mode = strict_mode\n        self._initialized = False\n        self._allowed_collections = allowed_collections\n        self._embedding_provider = embedding_provider\n        self._vector_store = vector_store\n\n        # Create the tools that will be exposed to the agent\n        self._discover_grimoriums_tool = FunctionTool(func=self.discover_grimoriums)\n        self._discover_spells_tool = FunctionTool(func=self.discover_spells)\n        self._execute_spell_tool = FunctionTool(func=self.execute_spell)\n\n        # Auto-initialize for backwards compatibility\n        if auto_initialize:\n            try:\n                self._sync_initialize()\n            except Exception as e:\n                logger.error(f\"AUTO-INIT FAILED: {e}\")\n                logger.warning(\n                    \"Grimorium is in an uninitialized state. \"\n                    \"Call 'await grimorium.initialize()' manually or check your configuration.\"\n                )\n                # Don't re-raise - allow object to exist in degraded state\n\n        logger.debug(\"Grimorium constructor completed.\")\n\n    def _sync_initialize(self) -&gt; None:\n        \"\"\"Synchronous initialization (for backwards compatibility).\"\"\"\n        if self._initialized:\n            return\n\n        logger.debug(\n            f\"Initializing Grimorium with root: {self.spell_sync.MAGETOOLS_ROOT}\"\n        )\n        discover_and_load_spells(\n            self.spell_sync.MAGETOOLS_ROOT,\n            registry=self.spell_sync.registry,\n            strict_mode=self._strict_mode,\n        )\n        self.spell_sync.sync_spells()\n        self._initialized = True\n        logger.debug(\"Grimorium initialized successfully (sync).\")\n\n    @property\n    def registry(self) -&gt; dict[str, Any]:\n        \"\"\"Get the registry of discovered spells.\"\"\"\n        return self.spell_sync.registry\n\n    async def initialize(self) -&gt; None:\n        \"\"\"Async initialization for non-blocking setup.\n\n        Call this after construction when using auto_initialize=False:\n\n            grimorium = Grimorium(auto_initialize=False)\n            await grimorium.initialize()\n\n        This method handles:\n        - Spell discovery from filesystem\n        - Database synchronization\n        - LLM-generated metadata (async)\n        \"\"\"\n        if self._initialized:\n            return\n\n        logger.debug(\n            f\"Initializing Grimorium (async) with root: {self.spell_sync.MAGETOOLS_ROOT}\"\n        )\n        discover_and_load_spells(\n            self.spell_sync.MAGETOOLS_ROOT,\n            registry=self.spell_sync.registry,\n            strict_mode=self._strict_mode,\n        )\n        self.spell_sync.sync_spells()\n        await self.spell_sync.sync_grimoriums_metadata_async()\n        self._initialized = True\n        logger.debug(\"Grimorium initialized successfully (async).\")\n\n    def _check_initialized(self) -&gt; None:\n        \"\"\"Raise error if not initialized.\"\"\"\n        if not self._initialized:\n            raise RuntimeError(\n                \"Grimorium not initialized. Call 'await grimorium.initialize()' first, \"\n                \"or use auto_initialize=True (default) in constructor.\"\n            )\n\n    @property\n    def usage_guide(self) -&gt; str:\n        \"\"\"Returns the usage guide instructions for using this toolset.\"\"\"\n        return grimorium_usage_guide\n\n    def discover_grimoriums(self, query: str) -&gt; dict[str, Any]:\n        \"\"\"Find relevant Grimoriums (Collections) based on a high-level goal.\n\n        Args:\n            query: High-level description of what you want to achieve.\n                   Example: \"process data\", \"manage files\", \"handle audio\"\n        \"\"\"\n        self._check_initialized()\n        results = self.spell_sync.find_relevant_grimoriums(query)\n        if not results:\n            return {\"status\": \"not_found\", \"message\": \"No relevant Grimoriums found.\"}\n\n        # Simplify output for the agent\n        simple_results = []\n        for r in results:\n            simple_results.append(\n                {\n                    \"id\": r[\"grimorium_id\"],\n                    \"description\": r[\"description\"][:200] + \"...\",  # Truncate\n                }\n            )\n\n        return {\n            \"status\": \"success\",\n            \"grimoriums\": simple_results,\n            \"next_step\": \"Use 'magetools_discover_spells(grimorium_id, query)' to find specific tools.\",\n        }\n\n    def discover_spells(self, grimorium_id: str, query: str) -&gt; dict[str, Any]:\n        \"\"\"Find specific spells (tools) within a selected Grimorium.\n\n        Args:\n            grimorium_id: The ID of the Grimorium to search (found via discover_grimoriums).\n            query: Specific action you want to perform.\n        \"\"\"\n        self._check_initialized()\n        spell_ids = self.spell_sync.find_spells_within_grimorium(grimorium_id, query)\n\n        if not spell_ids:\n            return {\n                \"status\": \"not_found\",\n                \"message\": f\"No spells found in '{grimorium_id}' matching '{query}'.\",\n            }\n\n        detailed_spells = {}\n        for name in spell_ids:\n            try:\n                func = self.spell_sync.registry[name]\n                sig = str(inspect.signature(func))\n                doc = inspect.getdoc(func) or \"No description.\"\n                detailed_spells[name] = {\"signature\": sig, \"description\": doc}\n            except Exception:\n                continue\n\n        return {\n            \"status\": \"success\",\n            \"grimorium\": grimorium_id,\n            \"spells\": detailed_spells,\n        }\n\n    async def execute_spell(\n        self, spell_name: str, arguments: dict[str, Any], tool_context: ToolContext\n    ) -&gt; dict[str, Any]:\n        \"\"\"Execute a specific spell by name.\n        Args:\n            spell_name: The exact name of the spell to find and execute.\n            arguments: A dictionary of arguments to pass to the spell function.\n        Returns:\n            The result of the spell execution.\n        \"\"\"\n        self._check_initialized()\n        logger.info(\n            f\"Grimorium executing spell: {spell_name} with args: {arguments}...\"\n        )\n\n        try:\n            # SECURITY CHECK: Verify spell is allowed for this instance\n            if not self.spell_sync.validate_spell_access(spell_name):\n                return {\n                    \"status\": \"error\",\n                    \"message\": f\"Permission denied: Spell '{spell_name}' is not in your allowed collections.\",\n                }\n\n            spell_func = self.spell_sync.registry[spell_name]\n        except KeyError:\n            return {\n                \"status\": \"error\",\n                \"message\": f\"Spell '{spell_name}' not found. Did you search for it first?\",\n            }\n        try:\n            # Check if the target spell function expects 'tool_context'\n            sig = inspect.signature(spell_func)\n\n            # Use a copy to avoid mutating the original arguments\n            call_args = arguments.copy()\n\n            # Robust injection of context by Type and Name\n            for name, param in sig.parameters.items():\n                if (\n                    param.annotation == ToolContext\n                    or name == \"tool_context\"\n                    and name not in call_args\n                ):\n                    call_args[name] = tool_context\n\n            # Execute the spell with the prepared arguments\n            if inspect.iscoroutinefunction(spell_func):\n                result = await spell_func(**call_args)\n            else:\n                # Run sync functions in a separate thread to keep the loop alive\n                result = await asyncio.to_thread(spell_func, **call_args)\n\n            return {\"status\": \"success\", \"result\": result}\n\n        except TypeError as te:\n            logger.error(f\"Argument mismatch for spell {spell_name}: {te}\")\n            return {\n                \"status\": \"error\",\n                \"message\": f\"Failed to call spell. Please check arguments. details: {str(te)}\",\n            }\n        except BaseException as e:\n            # Catch BaseException to protect the agent from misbehaving tools\n            # This includes KeyboardInterrupt, SystemExit, etc.\n            logger.error(\n                f\"Critical error executing spell {spell_name}: {type(e).__name__}: {e}\"\n            )\n            return {\n                \"status\": \"error\",\n                \"message\": f\"Execution failed: {type(e).__name__}: {str(e)}\",\n            }\n\n    async def get_tools(\n        self, readonly_context: ReadonlyContext | None = None\n    ) -&gt; list[BaseTool]:\n        \"\"\"Return the list of tools provided by this toolset.\"\"\"\n        return [\n            self._discover_grimoriums_tool,\n            self._discover_spells_tool,\n            self._execute_spell_tool,\n        ]\n\n    async def close(self) -&gt; None:\n        \"\"\"Cleanup resources.\"\"\"\n        logger.info(\"Closing Grimorium toolset...\")\n        await self.spell_sync.close()\n        await super().close()\n</code></pre>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.registry","title":"<code>registry</code>  <code>property</code>","text":"<p>Get the registry of discovered spells.</p>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.usage_guide","title":"<code>usage_guide</code>  <code>property</code>","text":"<p>Returns the usage guide instructions for using this toolset.</p>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.__init__","title":"<code>__init__(root_path=None, allowed_collections=None, embedding_provider=None, vector_store=None, config=None, strict_mode=True, auto_initialize=True)</code>","text":"<p>Initialize the Grimorium toolset.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str | None</code> <p>Optional path string to the project root.</p> <code>None</code> <code>allowed_collections</code> <code>list[str] | None</code> <p>Optional list of collection names.</p> <code>None</code> <code>embedding_provider</code> <code>Any</code> <p>Optional EmbeddingProviderProtocol implementation.</p> <code>None</code> <code>vector_store</code> <code>Any</code> <p>Optional VectorStoreProtocol implementation.</p> <code>None</code> <code>config</code> <code>MageToolsConfig | None</code> <p>Optional MageToolsConfig object.</p> <code>None</code> <code>strict_mode</code> <code>bool</code> <p>If True, only load spells from folders with manifest.json.</p> <code>True</code> <code>auto_initialize</code> <code>bool</code> <p>If True (default), run sync initialization in constructor            for backwards compatibility. Set to False for async usage.</p> <code>True</code> Source code in <code>src/magetools/grimorium.py</code> <pre><code>def __init__(\n    self,\n    root_path: str | None = None,\n    allowed_collections: list[str] | None = None,\n    embedding_provider: Any = None,\n    vector_store: Any = None,\n    config: MageToolsConfig | None = None,\n    strict_mode: bool = True,\n    auto_initialize: bool = True,\n):\n    \"\"\"Initialize the Grimorium toolset.\n\n    Args:\n        root_path: Optional path string to the project root.\n        allowed_collections: Optional list of collection names.\n        embedding_provider: Optional EmbeddingProviderProtocol implementation.\n        vector_store: Optional VectorStoreProtocol implementation.\n        config: Optional MageToolsConfig object.\n        strict_mode: If True, only load spells from folders with manifest.json.\n        auto_initialize: If True (default), run sync initialization in constructor\n                       for backwards compatibility. Set to False for async usage.\n    \"\"\"\n    # Initialize the base toolset with a prefix to avoid naming collisions\n    super().__init__(tool_name_prefix=\"magetools\")\n\n    self.config = config or get_config(\n        root_path=Path(root_path) if root_path else None\n    )\n    path_obj = self.config.root_path\n\n    # If root_path specifically provided, we trust it over auto-detection\n    # but if neither provided, we use the auto-detection from previous version as fallback for compatibility\n    if not root_path and not config:\n        # Magic: Auto-detect the caller's frame to find where Grimorium is instantiated\n        try:\n            # Stack[0] is here, Stack[1] is the caller\n            frame = inspect.stack()[1]\n            caller_file = frame.filename\n            if caller_file:\n                path_obj = Path(caller_file).parent.resolve()\n                logger.debug(\n                    f\"Auto-detected Grimorium root from caller: {path_obj}\"\n                )\n        except Exception as e:\n            logger.warning(f\"Could not auto-detect caller path: {e}\")\n\n        # Fallback to CWD if magic failed and no path provided\n        if not path_obj:\n            path_obj = Path.cwd()\n\n        # Update config with the auto-detected path\n        self.config.root_path = path_obj\n\n    self.spell_sync = SpellSync(\n        root_path=self.config.root_path,\n        allowed_collections=allowed_collections,\n        embedding_provider=embedding_provider,\n        vector_store=vector_store,\n        config=self.config,\n    )\n\n    self._strict_mode = strict_mode\n    self._initialized = False\n    self._allowed_collections = allowed_collections\n    self._embedding_provider = embedding_provider\n    self._vector_store = vector_store\n\n    # Create the tools that will be exposed to the agent\n    self._discover_grimoriums_tool = FunctionTool(func=self.discover_grimoriums)\n    self._discover_spells_tool = FunctionTool(func=self.discover_spells)\n    self._execute_spell_tool = FunctionTool(func=self.execute_spell)\n\n    # Auto-initialize for backwards compatibility\n    if auto_initialize:\n        try:\n            self._sync_initialize()\n        except Exception as e:\n            logger.error(f\"AUTO-INIT FAILED: {e}\")\n            logger.warning(\n                \"Grimorium is in an uninitialized state. \"\n                \"Call 'await grimorium.initialize()' manually or check your configuration.\"\n            )\n            # Don't re-raise - allow object to exist in degraded state\n\n    logger.debug(\"Grimorium constructor completed.\")\n</code></pre>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Cleanup resources.</p> Source code in <code>src/magetools/grimorium.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Cleanup resources.\"\"\"\n    logger.info(\"Closing Grimorium toolset...\")\n    await self.spell_sync.close()\n    await super().close()\n</code></pre>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.discover_grimoriums","title":"<code>discover_grimoriums(query)</code>","text":"<p>Find relevant Grimoriums (Collections) based on a high-level goal.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>High-level description of what you want to achieve.    Example: \"process data\", \"manage files\", \"handle audio\"</p> required Source code in <code>src/magetools/grimorium.py</code> <pre><code>def discover_grimoriums(self, query: str) -&gt; dict[str, Any]:\n    \"\"\"Find relevant Grimoriums (Collections) based on a high-level goal.\n\n    Args:\n        query: High-level description of what you want to achieve.\n               Example: \"process data\", \"manage files\", \"handle audio\"\n    \"\"\"\n    self._check_initialized()\n    results = self.spell_sync.find_relevant_grimoriums(query)\n    if not results:\n        return {\"status\": \"not_found\", \"message\": \"No relevant Grimoriums found.\"}\n\n    # Simplify output for the agent\n    simple_results = []\n    for r in results:\n        simple_results.append(\n            {\n                \"id\": r[\"grimorium_id\"],\n                \"description\": r[\"description\"][:200] + \"...\",  # Truncate\n            }\n        )\n\n    return {\n        \"status\": \"success\",\n        \"grimoriums\": simple_results,\n        \"next_step\": \"Use 'magetools_discover_spells(grimorium_id, query)' to find specific tools.\",\n    }\n</code></pre>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.discover_spells","title":"<code>discover_spells(grimorium_id, query)</code>","text":"<p>Find specific spells (tools) within a selected Grimorium.</p> <p>Parameters:</p> Name Type Description Default <code>grimorium_id</code> <code>str</code> <p>The ID of the Grimorium to search (found via discover_grimoriums).</p> required <code>query</code> <code>str</code> <p>Specific action you want to perform.</p> required Source code in <code>src/magetools/grimorium.py</code> <pre><code>def discover_spells(self, grimorium_id: str, query: str) -&gt; dict[str, Any]:\n    \"\"\"Find specific spells (tools) within a selected Grimorium.\n\n    Args:\n        grimorium_id: The ID of the Grimorium to search (found via discover_grimoriums).\n        query: Specific action you want to perform.\n    \"\"\"\n    self._check_initialized()\n    spell_ids = self.spell_sync.find_spells_within_grimorium(grimorium_id, query)\n\n    if not spell_ids:\n        return {\n            \"status\": \"not_found\",\n            \"message\": f\"No spells found in '{grimorium_id}' matching '{query}'.\",\n        }\n\n    detailed_spells = {}\n    for name in spell_ids:\n        try:\n            func = self.spell_sync.registry[name]\n            sig = str(inspect.signature(func))\n            doc = inspect.getdoc(func) or \"No description.\"\n            detailed_spells[name] = {\"signature\": sig, \"description\": doc}\n        except Exception:\n            continue\n\n    return {\n        \"status\": \"success\",\n        \"grimorium\": grimorium_id,\n        \"spells\": detailed_spells,\n    }\n</code></pre>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.execute_spell","title":"<code>execute_spell(spell_name, arguments, tool_context)</code>  <code>async</code>","text":"<p>Execute a specific spell by name. Args:     spell_name: The exact name of the spell to find and execute.     arguments: A dictionary of arguments to pass to the spell function. Returns:     The result of the spell execution.</p> Source code in <code>src/magetools/grimorium.py</code> <pre><code>async def execute_spell(\n    self, spell_name: str, arguments: dict[str, Any], tool_context: ToolContext\n) -&gt; dict[str, Any]:\n    \"\"\"Execute a specific spell by name.\n    Args:\n        spell_name: The exact name of the spell to find and execute.\n        arguments: A dictionary of arguments to pass to the spell function.\n    Returns:\n        The result of the spell execution.\n    \"\"\"\n    self._check_initialized()\n    logger.info(\n        f\"Grimorium executing spell: {spell_name} with args: {arguments}...\"\n    )\n\n    try:\n        # SECURITY CHECK: Verify spell is allowed for this instance\n        if not self.spell_sync.validate_spell_access(spell_name):\n            return {\n                \"status\": \"error\",\n                \"message\": f\"Permission denied: Spell '{spell_name}' is not in your allowed collections.\",\n            }\n\n        spell_func = self.spell_sync.registry[spell_name]\n    except KeyError:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Spell '{spell_name}' not found. Did you search for it first?\",\n        }\n    try:\n        # Check if the target spell function expects 'tool_context'\n        sig = inspect.signature(spell_func)\n\n        # Use a copy to avoid mutating the original arguments\n        call_args = arguments.copy()\n\n        # Robust injection of context by Type and Name\n        for name, param in sig.parameters.items():\n            if (\n                param.annotation == ToolContext\n                or name == \"tool_context\"\n                and name not in call_args\n            ):\n                call_args[name] = tool_context\n\n        # Execute the spell with the prepared arguments\n        if inspect.iscoroutinefunction(spell_func):\n            result = await spell_func(**call_args)\n        else:\n            # Run sync functions in a separate thread to keep the loop alive\n            result = await asyncio.to_thread(spell_func, **call_args)\n\n        return {\"status\": \"success\", \"result\": result}\n\n    except TypeError as te:\n        logger.error(f\"Argument mismatch for spell {spell_name}: {te}\")\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Failed to call spell. Please check arguments. details: {str(te)}\",\n        }\n    except BaseException as e:\n        # Catch BaseException to protect the agent from misbehaving tools\n        # This includes KeyboardInterrupt, SystemExit, etc.\n        logger.error(\n            f\"Critical error executing spell {spell_name}: {type(e).__name__}: {e}\"\n        )\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Execution failed: {type(e).__name__}: {str(e)}\",\n        }\n</code></pre>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.get_tools","title":"<code>get_tools(readonly_context=None)</code>  <code>async</code>","text":"<p>Return the list of tools provided by this toolset.</p> Source code in <code>src/magetools/grimorium.py</code> <pre><code>async def get_tools(\n    self, readonly_context: ReadonlyContext | None = None\n) -&gt; list[BaseTool]:\n    \"\"\"Return the list of tools provided by this toolset.\"\"\"\n    return [\n        self._discover_grimoriums_tool,\n        self._discover_spells_tool,\n        self._execute_spell_tool,\n    ]\n</code></pre>"},{"location":"reference/grimorium/#magetools.grimorium.Grimorium.initialize","title":"<code>initialize()</code>  <code>async</code>","text":"<p>Async initialization for non-blocking setup.</p> <p>Call this after construction when using auto_initialize=False:</p> <pre><code>grimorium = Grimorium(auto_initialize=False)\nawait grimorium.initialize()\n</code></pre> <p>This method handles: - Spell discovery from filesystem - Database synchronization - LLM-generated metadata (async)</p> Source code in <code>src/magetools/grimorium.py</code> <pre><code>async def initialize(self) -&gt; None:\n    \"\"\"Async initialization for non-blocking setup.\n\n    Call this after construction when using auto_initialize=False:\n\n        grimorium = Grimorium(auto_initialize=False)\n        await grimorium.initialize()\n\n    This method handles:\n    - Spell discovery from filesystem\n    - Database synchronization\n    - LLM-generated metadata (async)\n    \"\"\"\n    if self._initialized:\n        return\n\n    logger.debug(\n        f\"Initializing Grimorium (async) with root: {self.spell_sync.MAGETOOLS_ROOT}\"\n    )\n    discover_and_load_spells(\n        self.spell_sync.MAGETOOLS_ROOT,\n        registry=self.spell_sync.registry,\n        strict_mode=self._strict_mode,\n    )\n    self.spell_sync.sync_spells()\n    await self.spell_sync.sync_grimoriums_metadata_async()\n    self._initialized = True\n    logger.debug(\"Grimorium initialized successfully (async).\")\n</code></pre>"},{"location":"reference/spellsync/","title":"SpellSync","text":"<p>A magical synchronizer for matching and managing spells using Portable Spellbooks.</p> <p>Each subdirectory in the grimorium acts as a self-contained 'Grimorium' (Cartridge), containing its own ChromaDB database.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>class SpellSync:\n    \"\"\"A magical synchronizer for matching and managing spells using Portable Spellbooks.\n\n    Each subdirectory in the grimorium acts as a self-contained 'Grimorium' (Cartridge),\n    containing its own ChromaDB database.\n    \"\"\"\n\n    def __init__(\n        self,\n        root_path: Path | None = None,\n        allowed_collections: list[str] | None = None,\n        embedding_provider: EmbeddingProviderProtocol | None = None,\n        vector_store: VectorStoreProtocol | None = None,\n        config: MageToolsConfig | None = None,\n    ):\n        \"\"\"Initialize the SpellSync with a single unified database.\n\n        Args:\n            root_path: Optional path to the project root containing .magetools.\n                      If None, defaults to CWD or config.root_path.\n            allowed_collections: Optional list of collection names to restrict access to.\n                               If None, all collections are accessible.\n            config: Optional MageToolsConfig object.\n        \"\"\"\n        self.config = config or get_config(root_path=root_path)\n        self.top_spells = 5\n        # Distance threshold for filtering (Lower is better for distance metrics)\n        self.distance_threshold = 0.4\n        self.allowed_collections = allowed_collections\n        self.registry = {}\n\n        # Use root from config\n        self.MAGETOOLS_ROOT = self.config.magetools_root\n        db_path = self.config.db_path\n\n        # Ensure root grimorium folder exists\n        if not self.MAGETOOLS_ROOT.exists():\n            pass\n\n        # Dependency Injection / Defaults\n        if embedding_provider is None:\n            from .adapters import get_default_provider\n\n            self.embedding_provider = get_default_provider(config=self.config)\n        else:\n            self.embedding_provider = embedding_provider\n\n        if vector_store is None:\n            self.vector_store = ChromaVectorStore(path=str(db_path))\n        else:\n            self.vector_store = vector_store\n\n        self.embedding_function = self.embedding_provider.get_embedding_function()\n\n    def __getstate__(self):\n        \"\"\"Custom pickling to exclude unpickleable objects.\"\"\"\n        state = self.__dict__.copy()\n        if \"client\" in state:\n            del state[\"client\"]\n        if \"embedding_function\" in state:\n            del state[\"embedding_function\"]\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state and re-initialize unpickleable objects.\"\"\"\n        self.__dict__.update(state)\n        # Re-initialize\n        db_path = self.MAGETOOLS_ROOT / self.DB_FOLDER_NAME\n        self.client = chromadb.PersistentClient(path=str(db_path))\n\n    def get_grimorium_collection(self, collection_name: str):\n        \"\"\"Get or create a collection for a specific grimorium (folder).\"\"\"\n        return self.vector_store.get_or_create_collection(\n            name=collection_name,\n            embedding_function=self.embedding_function,\n        )\n\n    def find_matching_spells(self, query: str) -&gt; list[str]:\n        \"\"\"Find spells that match the given query across all valid collections.\"\"\"\n        if not query or not isinstance(query, str) or not query.strip():\n            logger.error(\"Error: Invalid query\")\n            return []\n\n        logger.info(f\"Searching for spells matching: {query[:50]}...\")\n        all_matches = []\n\n        # List all collections in the DB\n        # This is strictly faster than iterating the filesystem\n        try:\n            collections = self.vector_store.list_collections()\n        except Exception as e:\n            logger.error(f\"Failed to list collections: {e}\")\n            return []\n\n        for collection_obj in collections:\n            coll_name = collection_obj.name\n\n            # Filter by allowed_collections if set\n            if self.allowed_collections is not None:\n                if coll_name not in self.allowed_collections:\n                    continue\n\n            try:\n                # We need to get the collection object with our embedding function attached\n                # list_collections returns light objects without the EF\n                collection = self.vector_store.get_collection(\n                    name=coll_name, embedding_function=self.embedding_function\n                )\n\n                results = collection.query(\n                    query_texts=[query],\n                    n_results=self.top_spells,\n                    include=[\"documents\", \"distances\"],\n                )\n\n                if results and results[\"ids\"] and results[\"ids\"][0]:\n                    ids = results[\"ids\"][0]\n                    dists = results[\"distances\"][0]\n\n                    for i, spell_id in enumerate(ids):\n                        dist = dists[i]\n                        all_matches.append((spell_id, dist))\n\n            except Exception as e:\n                logger.warning(f\"Failed to search collection '{coll_name}': {e}\")\n\n        # Deduplicate matches keeping the lowest distance\n        unique_matches_map = {}\n        for spell_id, dist in all_matches:\n            if (\n                spell_id not in unique_matches_map\n                or dist &lt; unique_matches_map[spell_id]\n            ):\n                unique_matches_map[spell_id] = dist\n\n        # Sort by distance\n        sorted_matches = sorted(unique_matches_map.items(), key=lambda x: x[1])\n\n        if sorted_matches:\n            logger.debug(f\"Matches before filtering (name, distance): {sorted_matches}\")\n\n        # Filter by threshold logic\n        filtered_matches = [\n            match for match in sorted_matches if match[1] &lt;= self.distance_threshold\n        ]\n\n        # Near-miss reporting for debug mode\n        if self.config.debug:\n            near_misses = [\n                match\n                for match in sorted_matches\n                if self.distance_threshold &lt; match[1] &lt;= self.distance_threshold + 0.2\n            ]\n            if near_misses:\n                logger.info(f\"Near-miss spells (just above threshold): {near_misses}\")\n\n        # Return just the spell IDs (limited by top_spells)\n        return [match[0] for match in filtered_matches][: self.top_spells]\n\n    def find_relevant_grimoriums(self, query: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Find Grimoriums (Collections) that match the query.\"\"\"\n        if not query:\n            return []\n\n        logger.info(f\"Searching for Grimoriums matching: {query}...\")\n        try:\n            master_index = self.vector_store.get_or_create_collection(\n                name=GRIMORIUMS_INDEX_NAME, embedding_function=self.embedding_function\n            )\n\n            results = master_index.query(\n                query_texts=[query],\n                n_results=self.top_spells,  # reuse top_spells limit for now\n                include=[\"documents\", \"metadatas\", \"distances\"],\n            )\n\n            matches = []\n            if results and results[\"ids\"] and results[\"ids\"][0]:\n                for i, g_id in enumerate(results[\"ids\"][0]):\n                    dist = results[\"distances\"][0][i]\n                    if dist &lt;= self.distance_threshold:\n                        meta = results[\"metadatas\"][0][i]\n                        doc = results[\"documents\"][0][i]\n                        matches.append(\n                            {\n                                \"grimorium_id\": g_id,\n                                \"description\": doc,\n                                \"metadata\": meta,\n                                \"distance\": dist,\n                            }\n                        )\n\n            return sorted(matches, key=lambda x: x[\"distance\"])\n\n        except Exception as e:\n            logger.error(f\"Failed to search grimoriums: {e}\")\n            return []\n\n    def find_spells_within_grimorium(self, grimorium_id: str, query: str) -&gt; list[str]:\n        \"\"\"Find spells within a specific Grimorium.\"\"\"\n        logger.info(f\"Searching for '{query}' in Grimorium '{grimorium_id}'...\")\n\n        # Verify it's an allowed collection/grimorium\n        if self.allowed_collections and grimorium_id not in self.allowed_collections:\n            logger.warning(f\"Access denied to Grimorium '{grimorium_id}'\")\n            return []\n\n        try:\n            collection = self.vector_store.get_collection(\n                name=grimorium_id, embedding_function=self.embedding_function\n            )\n\n            results = collection.query(\n                query_texts=[query], n_results=self.top_spells, include=[\"distances\"]\n            )\n\n            matches = []\n            if results and results[\"ids\"] and results[\"ids\"][0]:\n                for i, spell_id in enumerate(results[\"ids\"][0]):\n                    dist = results[\"distances\"][0][i]\n                    if dist &lt;= self.distance_threshold:\n                        matches.append(spell_id)\n\n            return matches\n\n        except Exception as e:\n            logger.error(f\"Failed to search inside Grimorium '{grimorium_id}': {e}\")\n            return []\n\n    def validate_spell_access(self, spell_name: str) -&gt; bool:\n        \"\"\"Check if a spell is allowed to be accessed by this instance.\"\"\"\n        # If no restrictions, everything is allowed\n        if self.allowed_collections is None:\n            return True\n\n        # Use lists of collections to check (cache this?)\n        # For now, query the DB to be sure it exists in an allowed collection\n        try:\n            for coll_name in self.allowed_collections:\n                try:\n                    collection = self.vector_store.get_collection(\n                        name=coll_name, embedding_function=self.embedding_function\n                    )\n                    # Use get to check existence efficiently\n                    res = collection.get(ids=[spell_name], include=[])\n                    if res and res[\"ids\"]:\n                        return True\n                except Exception:\n                    continue\n\n            logger.warning(\n                f\"Access denied: Spell '{spell_name}' not found in allowed collections: {self.allowed_collections}\"\n            )\n            return False\n\n        except Exception as e:\n            logger.error(f\"Error validating spell access: {e}\")\n            return False\n\n    def sync_grimoriums_metadata(self):\n        \"\"\"Synchronizes high-level Grimorium metadata to the master index.\"\"\"\n        logger.info(\"Syncing Grimorium metadata...\")\n\n        # Get the master index collection\n        master_index = self.vector_store.get_or_create_collection(\n            name=GRIMORIUMS_INDEX_NAME, embedding_function=self.embedding_function\n        )\n\n        # Iterate through known collections (buckets)\n        # We can reuse the logic from sync_spells or simple filesystem iteration\n        # For now, let's walk the filesystem again to capture descriptions\n\n        folders = [\n            d\n            for d in self.MAGETOOLS_ROOT.iterdir()\n            if d.is_dir()\n            and not d.name.startswith((\".\", \"_\"))\n            and d.name != self.config.db_folder_name\n        ]\n\n        ids = []\n        documents = []\n        metadatas = []\n\n        for folder in folders:\n            grimorium_id = folder.name\n            current_hash = self._compute_grimorium_hash(folder)\n\n            # Check for existing summary file\n            summary_path = folder / \"grimorium_summary.md\"\n            description = \"\"\n\n            # Check if we have a stored hash in the index\n            stored_hash = \"\"\n            existing_results = master_index.get(ids=[grimorium_id])\n            if existing_results and existing_results[\"metadatas\"]:\n                stored_hash = existing_results[\"metadatas\"][0].get(\"hash\", \"\")\n\n            # If hash changed, we consider it \"missing\" to trigger re-generation\n            is_stale = stored_hash and stored_hash != current_hash\n\n            if summary_path.exists() and not is_stale:\n                description = summary_path.read_text(encoding=\"utf-8\")\n\n            # If missing, empty, or stale, generate it!\n            if not description or is_stale:\n                if is_stale:\n                    logger.info(\n                        f\"Summary for {grimorium_id} is stale. Re-generating...\"\n                    )\n                else:\n                    logger.info(\n                        f\"Auto-generating summary for Grimorium: {grimorium_id}\"\n                    )\n\n                spell_docs = []\n                # Gather docstrings from all spells in this folder\n                for py_file in folder.rglob(\"*.py\"):\n                    if py_file.name.startswith((\".\", \"_\")):\n                        continue\n                    try:\n                        source = py_file.read_text(encoding=\"utf-8\")\n                        module = ast.parse(source)\n                        # Extract module docstring\n                        module_doc = ast.get_docstring(module)\n                        if module_doc:\n                            spell_docs.append(f\"Module {py_file.stem}: {module_doc}\")\n\n                        # Extract function and class docstrings\n                        for node in ast.walk(module):\n                            if isinstance(\n                                node,\n                                (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef),\n                            ):\n                                doc = ast.get_docstring(node)\n                                if doc:\n                                    name = node.name\n                                    spell_docs.append(f\"Spell {name}: {doc}\")\n                    except Exception as e:\n                        logger.warning(f\"Failed to parse {py_file} for summary: {e}\")\n                        continue\n\n                if spell_docs:\n                    description = self._generate_grimorium_summary(\n                        grimorium_id, spell_docs\n                    )\n                    # Persist it\n                    try:\n                        summary_path.write_text(description, encoding=\"utf-8\")\n                    except Exception as e:\n                        logger.error(f\"Failed to write summary for {grimorium_id}: {e}\")\n\n            if not description:\n                description = f\"Collection of spells in {grimorium_id}\"\n\n            ids.append(grimorium_id)\n            documents.append(description)\n            metadatas.append(\n                {\n                    \"grimorium_id\": grimorium_id,\n                    \"spell_count\": len(list(folder.glob(\"*.py\"))),  # Rough count\n                    \"hash\": current_hash,\n                }\n            )\n\n        if ids:\n            master_index.upsert(ids=ids, documents=documents, metadatas=metadatas)\n            logger.info(f\"Updated metadata for {len(ids)} Grimoriums.\")\n\n    async def sync_grimoriums_metadata_async(self, concurrency: int = 5):\n        \"\"\"Async version of sync_grimoriums_metadata with parallel LLM calls.\"\"\"\n        logger.info(\"Syncing Grimorium metadata (async)...\")\n\n        master_index = self.vector_store.get_or_create_collection(\n            name=GRIMORIUMS_INDEX_NAME, embedding_function=self.embedding_function\n        )\n\n        folders = [\n            d\n            for d in self.MAGETOOLS_ROOT.iterdir()\n            if d.is_dir()\n            and not d.name.startswith((\".\", \"_\"))\n            and d.name != self.config.db_folder_name\n        ]\n\n        semaphore = asyncio.Semaphore(concurrency)\n\n        async def process_folder(folder: Path) -&gt; tuple[str, str, dict] | None:\n            async with semaphore:\n                grimorium_id = folder.name\n                current_hash = self._compute_grimorium_hash(folder)\n                summary_path = folder / \"grimorium_summary.md\"\n                description = \"\"\n\n                # Check stored hash\n                stored_hash = \"\"\n                existing_results = master_index.get(ids=[grimorium_id])\n                if existing_results and existing_results[\"metadatas\"]:\n                    stored_hash = existing_results[\"metadatas\"][0].get(\"hash\", \"\")\n\n                is_stale = stored_hash and stored_hash != current_hash\n\n                if summary_path.exists() and not is_stale:\n                    description = summary_path.read_text(encoding=\"utf-8\")\n\n                if not description or is_stale:\n                    logger.info(f\"Generating summary for {grimorium_id}...\")\n                    spell_docs = self._extract_spell_docs(folder)\n                    if spell_docs:\n                        description = await asyncio.to_thread(\n                            self._generate_grimorium_summary, grimorium_id, spell_docs\n                        )\n                        try:\n                            summary_path.write_text(description, encoding=\"utf-8\")\n                        except Exception as e:\n                            logger.error(\n                                f\"Failed to write summary for {grimorium_id}: {e}\"\n                            )\n\n                if not description:\n                    description = f\"Collection of spells in {grimorium_id}\"\n\n                return (\n                    grimorium_id,\n                    description,\n                    {\n                        \"grimorium_id\": grimorium_id,\n                        \"spell_count\": len(list(folder.glob(\"*.py\"))),\n                        \"hash\": current_hash,\n                    },\n                )\n\n        results = await asyncio.gather(*[process_folder(f) for f in folders])\n\n        ids, documents, metadatas = [], [], []\n        for result in results:\n            if result:\n                ids.append(result[0])\n                documents.append(result[1])\n                metadatas.append(result[2])\n\n        if ids:\n            master_index.upsert(ids=ids, documents=documents, metadatas=metadatas)\n            logger.info(f\"Updated metadata for {len(ids)} Grimoriums (async).\")\n\n    def _extract_spell_docs(self, folder: Path) -&gt; list[str]:\n        \"\"\"Extract docstrings from python files in a folder.\"\"\"\n        spell_docs = []\n        for py_file in folder.rglob(\"*.py\"):\n            if py_file.name.startswith((\".\", \"_\")):\n                continue\n            try:\n                source = py_file.read_text(encoding=\"utf-8\")\n                module = ast.parse(source)\n                module_doc = ast.get_docstring(module)\n                if module_doc:\n                    spell_docs.append(f\"Module {py_file.stem}: {module_doc}\")\n                for node in ast.walk(module):\n                    if isinstance(\n                        node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)\n                    ):\n                        doc = ast.get_docstring(node)\n                        if doc:\n                            spell_docs.append(f\"Spell {node.name}: {doc}\")\n            except Exception as e:\n                logger.warning(f\"Failed to parse {py_file} for summary: {e}\")\n        return spell_docs\n\n    def _generate_grimorium_summary(\n        self, grimorium_name: str, spell_docs: list[str]\n    ) -&gt; str:\n        \"\"\"Uses the AI Provider to generate a high-quality summary of the Grimorium.\"\"\"\n        prompt = f\"\"\"\nAnalyze the provided list of tools/functions in the '{grimorium_name}' collection.\nTask: You are an expert in information extraction and technical documentation analysis. \nGenerate a professional, high-density technical summary that distills collection capabilities while excluding operational details.\n\nRequirements:\n1. Identify the primary functional domains (e.g., File I/O, Authentication, Data Processing).\n2. If the tools are a \"ball of spells\" (disjointed/random), categorize them into logical thematic clusters.\n3. Use a neutral, technical tone. Avoid all fantasy, magical, or flowery language. \n4. Focus on what an agent can *do* with these tools.\n5. Do NOT include installation, configuration, or unrelated operational details.\n\nFollow this exact Markdown format:\n\n# Domains\n[Comma-separated list of technical areas covered]\n\n# Summary\n[2-3 sentence technical overview of the collection's purpose]\n\n# Major Capabilities\n- **[Theme 1]**: [Brief description of what tools in this theme achieve]\n- **[Theme 2]**: [Brief description of what tools in this theme achieve]\n\n# Key Search Keywords\n[List 5-10 keywords an agent might use to find this collection, these can be tool specific or general domain keywords]\n\nTools/Functions:\n{chr(10).join(spell_docs)[:8000]} \n\nSummary:\n\"\"\"\n        try:\n            return self.embedding_provider.generate_content(prompt)\n        except Exception as e:\n            logger.error(f\"Failed to generate summary: {e}\")\n            return f\"Grimorium {grimorium_name} containing various magical tools.\"\n\n    def _compute_grimorium_hash(self, folder_path: Path) -&gt; str:\n        \"\"\"Computes a hash of all python files in the folder to detect changes.\"\"\"\n        hasher = hashlib.md5()\n        # Sort files to ensure deterministic hash\n        py_files = sorted(list(folder_path.rglob(\"*.py\")))\n        for py_file in py_files:\n            if py_file.name.startswith((\".\", \"_\")):\n                continue\n            try:\n                # We hash the content to detect functional changes\n                content = py_file.read_bytes()\n                hasher.update(content)\n            except Exception:\n                continue\n        return hasher.hexdigest()\n\n    async def close(self) -&gt; None:\n        \"\"\"Cleanup synchronizer resources.\"\"\"\n        logger.debug(\"Closing SpellSync...\")\n        if hasattr(self.vector_store, \"close\"):\n            await self.vector_store.close()\n        if hasattr(self.embedding_provider, \"close\"):\n            await self.embedding_provider.close()\n\n    def sync_spells(self):\n        \"\"\"Synchronizes spells to the unified database, separated by collections.\"\"\"\n        logger.info(\"Starting unified spell synchronization...\")\n\n        all_spells = self.registry\n        if not all_spells:\n            return\n\n        # Group spells by book (collection)\n        book_buckets = {}\n        for spell_name, spell_func in all_spells.items():\n            # Determine collection from module name\n            module_name = getattr(spell_func, \"__module__\", \"\")\n\n            # Default to 'default' if unknown\n            book_name = \"default_grimorium\"\n\n            # Extract from module path: grimorium.discovered_spells.&lt;book_name&gt;.&lt;file&gt;\n            if module_name and module_name.startswith(\"magetools.discovered_spells.\"):\n                parts = module_name.split(\".\")\n                if len(parts) &gt;= 3:\n                    book_name = parts[2]\n\n            # Allow manual override\n            if hasattr(spell_func, COLLECTION_ATTR_NAME):\n                book_name = getattr(spell_func, COLLECTION_ATTR_NAME)\n\n            if book_name not in book_buckets:\n                book_buckets[book_name] = []\n            book_buckets[book_name].append((spell_name, spell_func))\n\n        # Process each bucket into its own collection\n        for book_name, spells in book_buckets.items():\n            logger.info(f\"Syncing collection: {book_name}\")\n\n            try:\n                collection = self.get_grimorium_collection(book_name)\n\n                # Fetch existing metadata for diffing (same logic as before)\n                existing_hashes = {}\n                try:\n                    result = collection.get(include=[\"metadatas\"])\n                    if result and result[\"ids\"]:\n                        for i, spell_id in enumerate(result[\"ids\"]):\n                            if result[\"metadatas\"] and len(result[\"metadatas\"]) &gt; i:\n                                meta = result[\"metadatas\"][i]\n                                if meta and \"hash\" in meta:\n                                    existing_hashes[spell_id] = meta[\"hash\"]\n                except Exception:\n                    existing_hashes = {}\n\n                ids = []\n                documents = []\n                metadatas = []\n                skipped = 0\n\n                for spell_name, spell_func in spells:\n                    docstring = spell_func.__doc__ or \"\"\n                    current_hash = hashlib.md5(docstring.encode(\"utf-8\")).hexdigest()\n\n                    if (\n                        spell_name in existing_hashes\n                        and existing_hashes[spell_name] == current_hash\n                    ):\n                        skipped += 1\n                        continue\n\n                    ids.append(spell_name)\n                    documents.append(docstring)\n                    metadatas.append({\"name\": spell_name, \"hash\": current_hash})\n\n                if ids:\n                    collection.upsert(ids=ids, documents=documents, metadatas=metadatas)\n                    logger.info(\n                        f\"Upserted {len(ids)} spells to collection '{book_name}'\"\n                    )\n\n                if skipped &gt; 0:\n                    logger.info(f\"Skipped {skipped} up-to-date spells in '{book_name}'\")\n\n            except Exception as e:\n                logger.error(f\"Failed to sync collection '{book_name}': {e}\")\n\n        logger.info(\"Unified spell synchronization complete.\")\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Custom pickling to exclude unpickleable objects.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def __getstate__(self):\n    \"\"\"Custom pickling to exclude unpickleable objects.\"\"\"\n    state = self.__dict__.copy()\n    if \"client\" in state:\n        del state[\"client\"]\n    if \"embedding_function\" in state:\n        del state[\"embedding_function\"]\n    return state\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.__init__","title":"<code>__init__(root_path=None, allowed_collections=None, embedding_provider=None, vector_store=None, config=None)</code>","text":"<p>Initialize the SpellSync with a single unified database.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>Path | None</code> <p>Optional path to the project root containing .magetools.       If None, defaults to CWD or config.root_path.</p> <code>None</code> <code>allowed_collections</code> <code>list[str] | None</code> <p>Optional list of collection names to restrict access to.                If None, all collections are accessible.</p> <code>None</code> <code>config</code> <code>MageToolsConfig | None</code> <p>Optional MageToolsConfig object.</p> <code>None</code> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def __init__(\n    self,\n    root_path: Path | None = None,\n    allowed_collections: list[str] | None = None,\n    embedding_provider: EmbeddingProviderProtocol | None = None,\n    vector_store: VectorStoreProtocol | None = None,\n    config: MageToolsConfig | None = None,\n):\n    \"\"\"Initialize the SpellSync with a single unified database.\n\n    Args:\n        root_path: Optional path to the project root containing .magetools.\n                  If None, defaults to CWD or config.root_path.\n        allowed_collections: Optional list of collection names to restrict access to.\n                           If None, all collections are accessible.\n        config: Optional MageToolsConfig object.\n    \"\"\"\n    self.config = config or get_config(root_path=root_path)\n    self.top_spells = 5\n    # Distance threshold for filtering (Lower is better for distance metrics)\n    self.distance_threshold = 0.4\n    self.allowed_collections = allowed_collections\n    self.registry = {}\n\n    # Use root from config\n    self.MAGETOOLS_ROOT = self.config.magetools_root\n    db_path = self.config.db_path\n\n    # Ensure root grimorium folder exists\n    if not self.MAGETOOLS_ROOT.exists():\n        pass\n\n    # Dependency Injection / Defaults\n    if embedding_provider is None:\n        from .adapters import get_default_provider\n\n        self.embedding_provider = get_default_provider(config=self.config)\n    else:\n        self.embedding_provider = embedding_provider\n\n    if vector_store is None:\n        self.vector_store = ChromaVectorStore(path=str(db_path))\n    else:\n        self.vector_store = vector_store\n\n    self.embedding_function = self.embedding_provider.get_embedding_function()\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore state and re-initialize unpickleable objects.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def __setstate__(self, state):\n    \"\"\"Restore state and re-initialize unpickleable objects.\"\"\"\n    self.__dict__.update(state)\n    # Re-initialize\n    db_path = self.MAGETOOLS_ROOT / self.DB_FOLDER_NAME\n    self.client = chromadb.PersistentClient(path=str(db_path))\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Cleanup synchronizer resources.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Cleanup synchronizer resources.\"\"\"\n    logger.debug(\"Closing SpellSync...\")\n    if hasattr(self.vector_store, \"close\"):\n        await self.vector_store.close()\n    if hasattr(self.embedding_provider, \"close\"):\n        await self.embedding_provider.close()\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.find_matching_spells","title":"<code>find_matching_spells(query)</code>","text":"<p>Find spells that match the given query across all valid collections.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def find_matching_spells(self, query: str) -&gt; list[str]:\n    \"\"\"Find spells that match the given query across all valid collections.\"\"\"\n    if not query or not isinstance(query, str) or not query.strip():\n        logger.error(\"Error: Invalid query\")\n        return []\n\n    logger.info(f\"Searching for spells matching: {query[:50]}...\")\n    all_matches = []\n\n    # List all collections in the DB\n    # This is strictly faster than iterating the filesystem\n    try:\n        collections = self.vector_store.list_collections()\n    except Exception as e:\n        logger.error(f\"Failed to list collections: {e}\")\n        return []\n\n    for collection_obj in collections:\n        coll_name = collection_obj.name\n\n        # Filter by allowed_collections if set\n        if self.allowed_collections is not None:\n            if coll_name not in self.allowed_collections:\n                continue\n\n        try:\n            # We need to get the collection object with our embedding function attached\n            # list_collections returns light objects without the EF\n            collection = self.vector_store.get_collection(\n                name=coll_name, embedding_function=self.embedding_function\n            )\n\n            results = collection.query(\n                query_texts=[query],\n                n_results=self.top_spells,\n                include=[\"documents\", \"distances\"],\n            )\n\n            if results and results[\"ids\"] and results[\"ids\"][0]:\n                ids = results[\"ids\"][0]\n                dists = results[\"distances\"][0]\n\n                for i, spell_id in enumerate(ids):\n                    dist = dists[i]\n                    all_matches.append((spell_id, dist))\n\n        except Exception as e:\n            logger.warning(f\"Failed to search collection '{coll_name}': {e}\")\n\n    # Deduplicate matches keeping the lowest distance\n    unique_matches_map = {}\n    for spell_id, dist in all_matches:\n        if (\n            spell_id not in unique_matches_map\n            or dist &lt; unique_matches_map[spell_id]\n        ):\n            unique_matches_map[spell_id] = dist\n\n    # Sort by distance\n    sorted_matches = sorted(unique_matches_map.items(), key=lambda x: x[1])\n\n    if sorted_matches:\n        logger.debug(f\"Matches before filtering (name, distance): {sorted_matches}\")\n\n    # Filter by threshold logic\n    filtered_matches = [\n        match for match in sorted_matches if match[1] &lt;= self.distance_threshold\n    ]\n\n    # Near-miss reporting for debug mode\n    if self.config.debug:\n        near_misses = [\n            match\n            for match in sorted_matches\n            if self.distance_threshold &lt; match[1] &lt;= self.distance_threshold + 0.2\n        ]\n        if near_misses:\n            logger.info(f\"Near-miss spells (just above threshold): {near_misses}\")\n\n    # Return just the spell IDs (limited by top_spells)\n    return [match[0] for match in filtered_matches][: self.top_spells]\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.find_relevant_grimoriums","title":"<code>find_relevant_grimoriums(query)</code>","text":"<p>Find Grimoriums (Collections) that match the query.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def find_relevant_grimoriums(self, query: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Find Grimoriums (Collections) that match the query.\"\"\"\n    if not query:\n        return []\n\n    logger.info(f\"Searching for Grimoriums matching: {query}...\")\n    try:\n        master_index = self.vector_store.get_or_create_collection(\n            name=GRIMORIUMS_INDEX_NAME, embedding_function=self.embedding_function\n        )\n\n        results = master_index.query(\n            query_texts=[query],\n            n_results=self.top_spells,  # reuse top_spells limit for now\n            include=[\"documents\", \"metadatas\", \"distances\"],\n        )\n\n        matches = []\n        if results and results[\"ids\"] and results[\"ids\"][0]:\n            for i, g_id in enumerate(results[\"ids\"][0]):\n                dist = results[\"distances\"][0][i]\n                if dist &lt;= self.distance_threshold:\n                    meta = results[\"metadatas\"][0][i]\n                    doc = results[\"documents\"][0][i]\n                    matches.append(\n                        {\n                            \"grimorium_id\": g_id,\n                            \"description\": doc,\n                            \"metadata\": meta,\n                            \"distance\": dist,\n                        }\n                    )\n\n        return sorted(matches, key=lambda x: x[\"distance\"])\n\n    except Exception as e:\n        logger.error(f\"Failed to search grimoriums: {e}\")\n        return []\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.find_spells_within_grimorium","title":"<code>find_spells_within_grimorium(grimorium_id, query)</code>","text":"<p>Find spells within a specific Grimorium.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def find_spells_within_grimorium(self, grimorium_id: str, query: str) -&gt; list[str]:\n    \"\"\"Find spells within a specific Grimorium.\"\"\"\n    logger.info(f\"Searching for '{query}' in Grimorium '{grimorium_id}'...\")\n\n    # Verify it's an allowed collection/grimorium\n    if self.allowed_collections and grimorium_id not in self.allowed_collections:\n        logger.warning(f\"Access denied to Grimorium '{grimorium_id}'\")\n        return []\n\n    try:\n        collection = self.vector_store.get_collection(\n            name=grimorium_id, embedding_function=self.embedding_function\n        )\n\n        results = collection.query(\n            query_texts=[query], n_results=self.top_spells, include=[\"distances\"]\n        )\n\n        matches = []\n        if results and results[\"ids\"] and results[\"ids\"][0]:\n            for i, spell_id in enumerate(results[\"ids\"][0]):\n                dist = results[\"distances\"][0][i]\n                if dist &lt;= self.distance_threshold:\n                    matches.append(spell_id)\n\n        return matches\n\n    except Exception as e:\n        logger.error(f\"Failed to search inside Grimorium '{grimorium_id}': {e}\")\n        return []\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.get_grimorium_collection","title":"<code>get_grimorium_collection(collection_name)</code>","text":"<p>Get or create a collection for a specific grimorium (folder).</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def get_grimorium_collection(self, collection_name: str):\n    \"\"\"Get or create a collection for a specific grimorium (folder).\"\"\"\n    return self.vector_store.get_or_create_collection(\n        name=collection_name,\n        embedding_function=self.embedding_function,\n    )\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.sync_grimoriums_metadata","title":"<code>sync_grimoriums_metadata()</code>","text":"<p>Synchronizes high-level Grimorium metadata to the master index.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def sync_grimoriums_metadata(self):\n    \"\"\"Synchronizes high-level Grimorium metadata to the master index.\"\"\"\n    logger.info(\"Syncing Grimorium metadata...\")\n\n    # Get the master index collection\n    master_index = self.vector_store.get_or_create_collection(\n        name=GRIMORIUMS_INDEX_NAME, embedding_function=self.embedding_function\n    )\n\n    # Iterate through known collections (buckets)\n    # We can reuse the logic from sync_spells or simple filesystem iteration\n    # For now, let's walk the filesystem again to capture descriptions\n\n    folders = [\n        d\n        for d in self.MAGETOOLS_ROOT.iterdir()\n        if d.is_dir()\n        and not d.name.startswith((\".\", \"_\"))\n        and d.name != self.config.db_folder_name\n    ]\n\n    ids = []\n    documents = []\n    metadatas = []\n\n    for folder in folders:\n        grimorium_id = folder.name\n        current_hash = self._compute_grimorium_hash(folder)\n\n        # Check for existing summary file\n        summary_path = folder / \"grimorium_summary.md\"\n        description = \"\"\n\n        # Check if we have a stored hash in the index\n        stored_hash = \"\"\n        existing_results = master_index.get(ids=[grimorium_id])\n        if existing_results and existing_results[\"metadatas\"]:\n            stored_hash = existing_results[\"metadatas\"][0].get(\"hash\", \"\")\n\n        # If hash changed, we consider it \"missing\" to trigger re-generation\n        is_stale = stored_hash and stored_hash != current_hash\n\n        if summary_path.exists() and not is_stale:\n            description = summary_path.read_text(encoding=\"utf-8\")\n\n        # If missing, empty, or stale, generate it!\n        if not description or is_stale:\n            if is_stale:\n                logger.info(\n                    f\"Summary for {grimorium_id} is stale. Re-generating...\"\n                )\n            else:\n                logger.info(\n                    f\"Auto-generating summary for Grimorium: {grimorium_id}\"\n                )\n\n            spell_docs = []\n            # Gather docstrings from all spells in this folder\n            for py_file in folder.rglob(\"*.py\"):\n                if py_file.name.startswith((\".\", \"_\")):\n                    continue\n                try:\n                    source = py_file.read_text(encoding=\"utf-8\")\n                    module = ast.parse(source)\n                    # Extract module docstring\n                    module_doc = ast.get_docstring(module)\n                    if module_doc:\n                        spell_docs.append(f\"Module {py_file.stem}: {module_doc}\")\n\n                    # Extract function and class docstrings\n                    for node in ast.walk(module):\n                        if isinstance(\n                            node,\n                            (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef),\n                        ):\n                            doc = ast.get_docstring(node)\n                            if doc:\n                                name = node.name\n                                spell_docs.append(f\"Spell {name}: {doc}\")\n                except Exception as e:\n                    logger.warning(f\"Failed to parse {py_file} for summary: {e}\")\n                    continue\n\n            if spell_docs:\n                description = self._generate_grimorium_summary(\n                    grimorium_id, spell_docs\n                )\n                # Persist it\n                try:\n                    summary_path.write_text(description, encoding=\"utf-8\")\n                except Exception as e:\n                    logger.error(f\"Failed to write summary for {grimorium_id}: {e}\")\n\n        if not description:\n            description = f\"Collection of spells in {grimorium_id}\"\n\n        ids.append(grimorium_id)\n        documents.append(description)\n        metadatas.append(\n            {\n                \"grimorium_id\": grimorium_id,\n                \"spell_count\": len(list(folder.glob(\"*.py\"))),  # Rough count\n                \"hash\": current_hash,\n            }\n        )\n\n    if ids:\n        master_index.upsert(ids=ids, documents=documents, metadatas=metadatas)\n        logger.info(f\"Updated metadata for {len(ids)} Grimoriums.\")\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.sync_grimoriums_metadata_async","title":"<code>sync_grimoriums_metadata_async(concurrency=5)</code>  <code>async</code>","text":"<p>Async version of sync_grimoriums_metadata with parallel LLM calls.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>async def sync_grimoriums_metadata_async(self, concurrency: int = 5):\n    \"\"\"Async version of sync_grimoriums_metadata with parallel LLM calls.\"\"\"\n    logger.info(\"Syncing Grimorium metadata (async)...\")\n\n    master_index = self.vector_store.get_or_create_collection(\n        name=GRIMORIUMS_INDEX_NAME, embedding_function=self.embedding_function\n    )\n\n    folders = [\n        d\n        for d in self.MAGETOOLS_ROOT.iterdir()\n        if d.is_dir()\n        and not d.name.startswith((\".\", \"_\"))\n        and d.name != self.config.db_folder_name\n    ]\n\n    semaphore = asyncio.Semaphore(concurrency)\n\n    async def process_folder(folder: Path) -&gt; tuple[str, str, dict] | None:\n        async with semaphore:\n            grimorium_id = folder.name\n            current_hash = self._compute_grimorium_hash(folder)\n            summary_path = folder / \"grimorium_summary.md\"\n            description = \"\"\n\n            # Check stored hash\n            stored_hash = \"\"\n            existing_results = master_index.get(ids=[grimorium_id])\n            if existing_results and existing_results[\"metadatas\"]:\n                stored_hash = existing_results[\"metadatas\"][0].get(\"hash\", \"\")\n\n            is_stale = stored_hash and stored_hash != current_hash\n\n            if summary_path.exists() and not is_stale:\n                description = summary_path.read_text(encoding=\"utf-8\")\n\n            if not description or is_stale:\n                logger.info(f\"Generating summary for {grimorium_id}...\")\n                spell_docs = self._extract_spell_docs(folder)\n                if spell_docs:\n                    description = await asyncio.to_thread(\n                        self._generate_grimorium_summary, grimorium_id, spell_docs\n                    )\n                    try:\n                        summary_path.write_text(description, encoding=\"utf-8\")\n                    except Exception as e:\n                        logger.error(\n                            f\"Failed to write summary for {grimorium_id}: {e}\"\n                        )\n\n            if not description:\n                description = f\"Collection of spells in {grimorium_id}\"\n\n            return (\n                grimorium_id,\n                description,\n                {\n                    \"grimorium_id\": grimorium_id,\n                    \"spell_count\": len(list(folder.glob(\"*.py\"))),\n                    \"hash\": current_hash,\n                },\n            )\n\n    results = await asyncio.gather(*[process_folder(f) for f in folders])\n\n    ids, documents, metadatas = [], [], []\n    for result in results:\n        if result:\n            ids.append(result[0])\n            documents.append(result[1])\n            metadatas.append(result[2])\n\n    if ids:\n        master_index.upsert(ids=ids, documents=documents, metadatas=metadatas)\n        logger.info(f\"Updated metadata for {len(ids)} Grimoriums (async).\")\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.sync_spells","title":"<code>sync_spells()</code>","text":"<p>Synchronizes spells to the unified database, separated by collections.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def sync_spells(self):\n    \"\"\"Synchronizes spells to the unified database, separated by collections.\"\"\"\n    logger.info(\"Starting unified spell synchronization...\")\n\n    all_spells = self.registry\n    if not all_spells:\n        return\n\n    # Group spells by book (collection)\n    book_buckets = {}\n    for spell_name, spell_func in all_spells.items():\n        # Determine collection from module name\n        module_name = getattr(spell_func, \"__module__\", \"\")\n\n        # Default to 'default' if unknown\n        book_name = \"default_grimorium\"\n\n        # Extract from module path: grimorium.discovered_spells.&lt;book_name&gt;.&lt;file&gt;\n        if module_name and module_name.startswith(\"magetools.discovered_spells.\"):\n            parts = module_name.split(\".\")\n            if len(parts) &gt;= 3:\n                book_name = parts[2]\n\n        # Allow manual override\n        if hasattr(spell_func, COLLECTION_ATTR_NAME):\n            book_name = getattr(spell_func, COLLECTION_ATTR_NAME)\n\n        if book_name not in book_buckets:\n            book_buckets[book_name] = []\n        book_buckets[book_name].append((spell_name, spell_func))\n\n    # Process each bucket into its own collection\n    for book_name, spells in book_buckets.items():\n        logger.info(f\"Syncing collection: {book_name}\")\n\n        try:\n            collection = self.get_grimorium_collection(book_name)\n\n            # Fetch existing metadata for diffing (same logic as before)\n            existing_hashes = {}\n            try:\n                result = collection.get(include=[\"metadatas\"])\n                if result and result[\"ids\"]:\n                    for i, spell_id in enumerate(result[\"ids\"]):\n                        if result[\"metadatas\"] and len(result[\"metadatas\"]) &gt; i:\n                            meta = result[\"metadatas\"][i]\n                            if meta and \"hash\" in meta:\n                                existing_hashes[spell_id] = meta[\"hash\"]\n            except Exception:\n                existing_hashes = {}\n\n            ids = []\n            documents = []\n            metadatas = []\n            skipped = 0\n\n            for spell_name, spell_func in spells:\n                docstring = spell_func.__doc__ or \"\"\n                current_hash = hashlib.md5(docstring.encode(\"utf-8\")).hexdigest()\n\n                if (\n                    spell_name in existing_hashes\n                    and existing_hashes[spell_name] == current_hash\n                ):\n                    skipped += 1\n                    continue\n\n                ids.append(spell_name)\n                documents.append(docstring)\n                metadatas.append({\"name\": spell_name, \"hash\": current_hash})\n\n            if ids:\n                collection.upsert(ids=ids, documents=documents, metadatas=metadatas)\n                logger.info(\n                    f\"Upserted {len(ids)} spells to collection '{book_name}'\"\n                )\n\n            if skipped &gt; 0:\n                logger.info(f\"Skipped {skipped} up-to-date spells in '{book_name}'\")\n\n        except Exception as e:\n            logger.error(f\"Failed to sync collection '{book_name}': {e}\")\n\n    logger.info(\"Unified spell synchronization complete.\")\n</code></pre>"},{"location":"reference/spellsync/#magetools.spellsync.SpellSync.validate_spell_access","title":"<code>validate_spell_access(spell_name)</code>","text":"<p>Check if a spell is allowed to be accessed by this instance.</p> Source code in <code>src/magetools/spellsync.py</code> <pre><code>def validate_spell_access(self, spell_name: str) -&gt; bool:\n    \"\"\"Check if a spell is allowed to be accessed by this instance.\"\"\"\n    # If no restrictions, everything is allowed\n    if self.allowed_collections is None:\n        return True\n\n    # Use lists of collections to check (cache this?)\n    # For now, query the DB to be sure it exists in an allowed collection\n    try:\n        for coll_name in self.allowed_collections:\n            try:\n                collection = self.vector_store.get_collection(\n                    name=coll_name, embedding_function=self.embedding_function\n                )\n                # Use get to check existence efficiently\n                res = collection.get(ids=[spell_name], include=[])\n                if res and res[\"ids\"]:\n                    return True\n            except Exception:\n                continue\n\n        logger.warning(\n            f\"Access denied: Spell '{spell_name}' not found in allowed collections: {self.allowed_collections}\"\n        )\n        return False\n\n    except Exception as e:\n        logger.error(f\"Error validating spell access: {e}\")\n        return False\n</code></pre>"},{"location":"user_guide/cli/","title":"CLI Reference","text":"<p>Magetools provides a command-line interface for managing your tool collections.</p>"},{"location":"user_guide/cli/#uv-run-m-magetools-init","title":"<code>uv run -m magetools init</code>","text":"<p>Initialize a new tool collection directory.</p> <p>Usage: <pre><code>uv run -m magetools init &lt;directory&gt;\n</code></pre></p> <p>What it does: - Scans the directory for Python files. - Creates a <code>manifest.json</code> file. - Enables the collection for Strict Mode.</p>"},{"location":"user_guide/cli/#uv-run-m-magetools-scan","title":"<code>uv run -m magetools scan</code>","text":"<p>Audit your tools and verify synchronization status.</p> <p>Usage: <pre><code>uv run -m magetools scan\n</code></pre></p> <p>What it does: - Discovers all tools in the <code>.magetools</code> directory. - Verifies manifest validity. - Indexes spells into the vector store. - Reports any failed imports (Quarantine).</p>"},{"location":"user_guide/core_concepts/","title":"Core Concepts","text":""},{"location":"user_guide/core_concepts/#grimorium-the-spellbook","title":"Grimorium (The Spellbook)","text":"<p>The <code>Grimorium</code> is the central coordinator. It manages the lifecycle of tools, their discovery, and their execution. It acts as a standard ADK <code>BaseToolset</code>.</p>"},{"location":"user_guide/core_concepts/#spells-the-tools","title":"Spells (The Tools)","text":"<p>A \"Spell\" is simply a Python function. Magetools extracts the name, docstring, and signature to represent the tool to the LLM.</p>"},{"location":"user_guide/core_concepts/#collections-the-chapters","title":"Collections (The Chapters)","text":"<p>Tools are grouped into directories called Collections. Each collection can have its own <code>manifest.json</code> to control permissions and metadata.</p>"},{"location":"user_guide/core_concepts/#active-discovery","title":"Active Discovery","text":"<p>Unlike static tool definitions, Magetools scans for new files and changes at runtime. This allows you to add capabilities to an agent without restarting the process or redeploying code.</p>"},{"location":"user_guide/getting_started/","title":"Getting Started with Magetools","text":""},{"location":"user_guide/getting_started/#installation","title":"Installation","text":"<p>Install the core package:</p> <pre><code>uv add magetools\n</code></pre> <p>For full functionality (including Google GenAI and ChromaDB):</p> <pre><code>uv add magetools[full]\n</code></pre>"},{"location":"user_guide/getting_started/#your-first-spellbook-grimorium","title":"Your First Spellbook (Grimorium)","text":"<ol> <li> <p>Create a tools directory:    <pre><code>mkdir .magetools\n</code></pre></p> </li> <li> <p>Add a \"Spell\" (Tool):    Create <code>.magetools/math_spells.py</code>:    <pre><code>def add_numbers(x: int, y: int) -&gt; int:\n    \"\"\"Add two numbers together.\"\"\"\n    return x + y\n</code></pre></p> </li> <li> <p>Initialize the Manifest:    Magetools requires a manifest for security:    <pre><code>uv run -m magetools init .magetools\n</code></pre></p> </li> <li> <p>Use it in Python:    <pre><code>from magetools.grimorium import Grimorium\nimport asyncio\n\nasync def main():\n    grim = Grimorium()\n    await grim.initialize()\n    print(f\"Loaded {len(grim.registry)} tools!\")\n\nasyncio.run(main())\n</code></pre></p> </li> </ol>"},{"location":"user_guide/security/","title":"Security &amp; Strict Mode","text":"<p>Magetools is designed for safe execution of agentic tools.</p>"},{"location":"user_guide/security/#strict-mode","title":"Strict Mode","text":"<p>By default, Magetools runs in Strict Mode. This means: 1. Every tool collection MUST have a <code>manifest.json</code>. 2. The manifest must have <code>\"enabled\": true</code>. 3. Only safe imports are allowed (imports are sanitized).</p>"},{"location":"user_guide/security/#the-manifest-manifestjson","title":"The Manifest (<code>manifest.json</code>)","text":"<p>The manifest allows fine-grained control over what tools are exposed:</p> <pre><code>{\n  \"name\": \"Math Collection\",\n  \"description\": \"Basic arithmetic tools\",\n  \"enabled\": true,\n  \"whitelist\": [\"add_numbers\", \"multiply_numbers\"],\n  \"blacklist\": [\"secret_function\"]\n}\n</code></pre>"},{"location":"user_guide/security/#quarantine","title":"Quarantine","text":"<p>If a spell file contains syntax errors or fails to load during discovery, it is moved to a virtual Quarantine. This prevents a single broken file from crashing the entire system.</p>"}]}